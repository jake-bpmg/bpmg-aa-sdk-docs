Working example of nestjs

```ts
import { Injectable, Logger } from "@nestjs/common";
import { bundler, accountAbstraction } from "bpmg-aa-sdk";
import type {
  IBundlerServiceConfig,
  IAccountAbstractionServiceConfig,
  HexType,
  IEstimateUserOperationGas,
  OnChainAssetType,
  IUserOperation,
} from "bpmg-aa-sdk";

@ApiOkResponse()
@ApiQuery({ type: String, name: "asset", enum: ["erc20", "erc721"] })
@HttpCode(HttpStatus.OK)
@Get("/sdk")
async submitUserOpWithSdk(@Query() query: { asset: OnChainAssetType }) {
  const { asset } = query;
  const exampleValue = {
    userId: "939e9283-a510-461b-b3b0-70cd6fd1c054",
    owner: "0xBf59115DB3b58cd8E6BAD8Ad05ED7bA81ee9735B",
    preSmartAccount: "0xBC76069cd81cB6bDe0AA24E7c7562990F9d820dC",
    salt: "aec352fae1",
  };

  // @note user wallet signing userop struct and contract deployer is different, and this might affect signature verification
  // meaning, exampleValue.owner and ROOT_WALLET_PRIVATE_KEY should be matched in this example case
  const { ROOT_WALLET_PRIVATE_KEY } = process.env;
  const { deployer, provider } = this.bpmgSdkService.getRelayers();
  const ownerWallet = new Wallet(ROOT_WALLET_PRIVATE_KEY, provider);

  const { digestAsBytes, digestAsString, userOperation } =
    await this.bpmgSdkService.encodeSignableUserOpHashByAsset({
      salt: exampleValue.salt,
      owner: exampleValue.owner as HexType,
      asset,
    });

  const signature = await ownerWallet.signMessage(digestAsBytes);
  const { signedUserOp } =
    await this.bpmgSdkService.buildSubmittableUserOperation({
      signature,
      userOp: userOperation.unpacked,
    });

  this.logger.debug(
      `submitUserOpWithSdk: running bundler reputation check, starting account factory validation`
  );
  const { hasFactoryStaked } =
      await this.bpmgSdkService.validateFactoryStake();

  if (!hasFactoryStaked) {
    throw new Error(
      "submitUserOpWithSdk: account factory needs to stake first"
    );
  }

  let userOpsResultAsHash: SkandhaSendUserOperationResponse | null = null;
  const { usePaymaster } = this.bpmgSdkService.isPaymasterEnabled();

  switch (usePaymaster) {
    case true:
    this.logger.debug(
      `submitUserOpWithSdk: running with paymaster, starting paymaster validation`
    );

    const { hasPaymasterDeposited, hasPaymasterStaked } =
      await this.bpmgSdkService.validatePaymasterDepositAndStake();

    if (!hasPaymasterDeposited || !hasPaymasterStaked) {
      throw new Error(
        "submitUserOpWithSdk: paymaster needs to deposit and stake before userop submission"
      );
    }

    const withPaymaster = await this.bpmgSdkService.submitUserOperation({
      userOp: signedUserOp,
    });
    userOpsResultAsHash = withPaymaster.userOpsResultAsHash;
    break;

    case false:
    this.logger.debug(
      `submitUserOpWithSdk: running withoutpaymaster, starting account validation`
    );

    const { hasAccountDeposited } =
      await this.bpmgSdkService.validateAccountDepositWhenPaymasterDisabled(
        {
          smartAccount: signedUserOp.sender as HexType,
        }
      );

      if (!hasAccountDeposited) {
        throw new Error(
          "submitUserOpWithSdk: account needs prefund when paymaster disabled"
        );
      }
      const withoutPaymaster = await this.bpmgSdkService.submitUserOperation({
        userOp: signedUserOp,
      });
      userOpsResultAsHash = withoutPaymaster.userOpsResultAsHash;
      break;

      default:
      break;
  }

  return { userOpsResultAsHash };
}
```
